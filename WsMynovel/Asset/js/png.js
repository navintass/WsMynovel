/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/png-js@1.0.0/png-node.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const fs = require("fs"), zlib = require("zlib"); module.exports = class t { static decode(e, s) { return fs.readFile(e, function (e, a) { return new t(a).decode(t => s(t)) }) } static load(e) { const s = fs.readFileSync(e); return new t(s) } constructor(t) { let e; for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.text = {}; ;) { const t = this.readUInt32(); let o = ""; for (e = 0; e < 4; e++)o += String.fromCharCode(this.data[this.pos++]); switch (o) { case "IHDR": this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++]; break; case "PLTE": this.palette = this.read(t); break; case "IDAT": for (e = 0; e < t; e++)this.imgData.push(this.data[this.pos++]); break; case "tRNS": switch (this.transparency = {}, this.colorType) { case 3: this.transparency.indexed = this.read(t); var s = 255 - this.transparency.indexed.length; if (s > 0) for (e = 0; e < s; e++)this.transparency.indexed.push(255); break; case 0: this.transparency.grayscale = this.read(t)[0]; break; case 2: this.transparency.rgb = this.read(t) }break; case "tEXt": var a = this.read(t), i = a.indexOf(0), r = String.fromCharCode.apply(String, a.slice(0, i)); this.text[r] = String.fromCharCode.apply(String, a.slice(i + 1)); break; case "IEND": switch (this.colorType) { case 0: case 3: case 4: this.colors = 1; break; case 2: case 6: this.colors = 3 }this.hasAlphaChannel = [4, 6].includes(this.colorType); var h = this.colors + (this.hasAlphaChannel ? 1 : 0); switch (this.pixelBitlength = this.bits * h, this.colors) { case 1: this.colorSpace = "DeviceGray"; break; case 3: this.colorSpace = "DeviceRGB" }return void (this.imgData = new Buffer(this.imgData)); default: this.pos += t }if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file") } } read(t) { const e = new Array(t); for (let s = 0; s < t; s++)e[s] = this.data[this.pos++]; return e } readUInt32() { return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++] } readUInt16() { return this.data[this.pos++] << 8 | this.data[this.pos++] } decodePixels(t) { return zlib.inflate(this.imgData, (e, s) => { if (e) throw e; const { width: a, height: i } = this, r = this.pixelBitlength / 8, h = new Buffer(a * i * r), { length: o } = s; let n = 0; function c(t, e, c, l, d = !1) { const p = Math.ceil((a - t) / c), f = Math.ceil((i - e) / l), u = r * p, g = d ? h : new Buffer(u * f); let b = 0, w = 0; for (; b < f && n < o;) { var y, k, m, x, D; switch (s[n++]) { case 0: for (m = 0; m < u; m++)g[w++] = s[n++]; break; case 1: for (m = 0; m < u; m++)y = s[n++], x = m < r ? 0 : g[w - r], g[w++] = (y + x) % 256; break; case 2: for (m = 0; m < u; m++)y = s[n++], k = (m - m % r) / r, D = b && g[(b - 1) * u + k * r + m % r], g[w++] = (D + y) % 256; break; case 3: for (m = 0; m < u; m++)y = s[n++], k = (m - m % r) / r, x = m < r ? 0 : g[w - r], D = b && g[(b - 1) * u + k * r + m % r], g[w++] = (y + Math.floor((x + D) / 2)) % 256; break; case 4: for (m = 0; m < u; m++) { var I, v; y = s[n++], k = (m - m % r) / r, x = m < r ? 0 : g[w - r], 0 === b ? D = v = 0 : (D = g[(b - 1) * u + k * r + m % r], v = k && g[(b - 1) * u + (k - 1) * r + m % r]); const t = x + D - v, e = Math.abs(t - x), a = Math.abs(t - D), i = Math.abs(t - v); I = e <= a && e <= i ? x : a <= i ? D : v, g[w++] = (y + I) % 256 } break; default: throw new Error(`Invalid filter algorithm: ${s[n - 1]}`) }if (!d) { let s = ((e + b * l) * a + t) * r, i = b * u; for (m = 0; m < p; m++) { for (let t = 0; t < r; t++)h[s++] = g[i++]; s += (c - 1) * r } } b++ } } return 1 === this.interlaceMethod ? (c(0, 0, 8, 8), c(4, 0, 8, 8), c(0, 4, 4, 8), c(2, 0, 4, 4), c(0, 2, 2, 4), c(1, 0, 2, 2), c(0, 1, 1, 2)) : c(0, 0, 1, 1, !0), t(h) }) } decodePalette() { const { palette: t } = this, { length: e } = t, s = this.transparency.indexed || [], a = new Buffer(s.length + e); let i = 0, r = 0; for (let o = 0; o < e; o += 3) { var h; a[i++] = t[o], a[i++] = t[o + 1], a[i++] = t[o + 2], a[i++] = null != (h = s[r++]) ? h : 255 } return a } copyToImageData(t, e) { let s, a, { colors: i } = this, r = null, h = this.hasAlphaChannel; this.palette.length && (r = this._decodedPalette || (this._decodedPalette = this.decodePalette()), i = 4, h = !0); const o = t.data || t, { length: n } = o, c = r || e; let l = s = 0; if (1 === i) for (; l < n;) { a = r ? 4 * e[l / 4] : s; const t = c[a++]; o[l++] = t, o[l++] = t, o[l++] = t, o[l++] = h ? c[a++] : 255, s = a } else for (; l < n;)a = r ? 4 * e[l / 4] : s, o[l++] = c[a++], o[l++] = c[a++], o[l++] = c[a++], o[l++] = h ? c[a++] : 255, s = a } decode(t) { const e = new Buffer(this.width * this.height * 4); return this.decodePixels(s => (this.copyToImageData(e, s), t(e))) } };
//# sourceMappingURL=/sm/dcb58ba671e3e341cf96b8a59e11112bc829921ee72bbe3e5a529fc89753c554.map